锁的获取与释放：同步块，JVM 管理。显式锁，手动管理

可中断性：同步块，不可中断，由 jvm 管理，没有中断方法
显式锁，可中断，手动管理，有中断方法。

公平性：同步块，不公平，不由线程先后顺序决定调用顺序。
显式锁，可设置公平锁。

尝试非阻塞获取锁： 同步块，不能非阻塞获取。线程只能阻塞等待获取锁。
显式锁：可立即返回是否成功获取锁，或设置超时时间。

条件变量：同步块：可以线程通信，但一个锁只有一个条件队列
显式锁：多条件对象，细粒度线程通信。

性能和优化：同步块，jvm 已经做了很多优化，性能接近显式锁。
显式锁：极端高并发情况下，trylock()方法或超时机制可能更高效。

可重入性：都支持同一线程多次获取同一把锁，避免死锁。

异常处理：同步块，因为是 jvm 管理的，所以异常时自动会释放锁，避免死锁。
显式锁，手动设置的，而且是显式的，当然都手动在 finally 中释放锁了。

适用场景：同步块：简单场景、代码量少、无需复杂锁功能。比如单例、线程安全的计数器。
显式锁：所以高级功能的场景。例如线程池任务调度、复杂状态机的并非控制。

### 总结对比表

| **特性**             | **synchronized** | **ReentrantLock**                |
| -------------------- | ---------------- | -------------------------------- |
| **锁类型**           | 隐式锁           | 显式锁                           |
| **锁获取方式**       | 自动获取与释放   | 手动 `lock()` 和 `unlock()`      |
| **可中断性**         | 不支持           | 支持（`lockInterruptibly()`）    |
| **公平性**           | 仅非公平锁       | 支持公平与非公平（构造函数指定） |
| **尝试非阻塞获取锁** | 不支持           | 支持（`tryLock()`）              |
| **条件变量**         | 单一条件队列     | 多个 `Condition` 对象            |
| **性能**             | 优化后接近显式锁 | 高竞争下可能更优                 |
| **代码复杂度**       | 简单             | 复杂（需手动管理）               |
| **适用场景**         | 简单同步需求     | 复杂并发控制                     |
